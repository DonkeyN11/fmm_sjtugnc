#!/usr/bin/env python3
"""
Visualise selected CMM trajectories (with covariance metadata) over the road network.

Example:
    python python/plot_cmm_trajectory.py \\
        --cmm-csv tmp/cmm_test5/cmm_trajectory.csv \\
        --network input/map/haikou/edges.shp \\
        --output tmp/cmm_test5/cmm_selected.png \\
        --ids 1 2 5
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Iterable, List, Sequence

import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import shapely.geometry
import shapely.wkt


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot trajectories from cmm_trajectory.csv on top of a road network.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--cmm-csv", type=Path, required=True,
                        help="Path to cmm_trajectory.csv generated by generate_data_cmm.py.")
    parser.add_argument("--network", type=Path, required=True,
                        help="Road network shapefile (or other vector source) for context.")
    parser.add_argument("--output", type=Path, required=True,
                        help="Destination PNG file.")
    parser.add_argument("--ids", type=int, nargs="*", default=None,
                        help="Trajectory IDs to plot. If omitted, all trajectories will be shown.")
    parser.add_argument("--dpi", type=int, default=200, help="Rendered image resolution.")
    parser.add_argument("--figsize", type=float, nargs=2, default=(10.0, 10.0),
                        metavar=("WIDTH", "HEIGHT"),
                        help="Figure size in inches (width height).")
    parser.add_argument("--show-pl", action="store_true",
                        help="Draw protection level circles at each timestamp.")
    parser.add_argument("--pl-scale", type=float, default=1.0,
                        help="Scale multiplier for protection level markers (in degrees).")
    parser.add_argument("--trajectory-alpha", type=float, default=0.95,
                        help="Transparency for trajectory lines.")
    parser.add_argument("--road-alpha", type=float, default=0.6,
                        help="Transparency for the road network.")
    return parser.parse_args(argv)


def load_cmm_trajectories(path: Path, ids: Iterable[int] | None) -> gpd.GeoDataFrame:
    df = pd.read_csv(path, delimiter=";")
    if "geom" not in df.columns:
        raise ValueError(f"Expected 'geom' column in {path}")
    df["geometry"] = df["geom"].map(shapely.wkt.loads)
    if ids:
        selected_ids = set(ids)
        df = df[df["id"].isin(selected_ids)].copy()
        if len(df.index) == 0:
            raise ValueError(f"No trajectories with specified ids {sorted(selected_ids)} found in {path}")
    gdf = gpd.GeoDataFrame(df, geometry="geometry", crs="EPSG:4326")
    return gdf


def load_network(path: Path) -> gpd.GeoDataFrame:
    gdf = gpd.read_file(path)
    if gdf.crs is None:
        raise ValueError(f"Network file {path} does not define a CRS")
    return gdf.to_crs("EPSG:4326")


def plot_protection_levels(ax: plt.Axes,
                           row: pd.Series,
                           scale: float,
                           color) -> None:
    protection_levels = json.loads(row["protection_levels"])
    coords: List[List[float]]
    if isinstance(row["geom"], str):
        geom = shapely.wkt.loads(row["geom"])
        coords = list(geom.coords)
    else:
        geom = row["geometry"]
        coords = list(geom.coords)

    for (lon, lat), pl in zip(coords, protection_levels):
        radius_deg = pl * scale
        circle = plt.Circle((lon, lat), radius_deg,
                            edgecolor=color,
                            facecolor="none",
                            alpha=0.4,
                            linewidth=0.8)
        ax.add_patch(circle)


def plot_trajectories(trajectories: gpd.GeoDataFrame,
                      network: gpd.GeoDataFrame,
                      output: Path,
                      dpi: int,
                      figsize: tuple[float, float],
                      trajectory_alpha: float,
                      road_alpha: float,
                      show_pl: bool,
                      pl_scale: float) -> None:
    fig, ax = plt.subplots(figsize=figsize)
    network.plot(ax=ax, color="#b0b0b0", linewidth=0.5, alpha=road_alpha)

    try:
        import seaborn as sns  # type: ignore

        palette = sns.color_palette("husl", len(trajectories))
    except ImportError:
        palette = plt.cm.get_cmap("tab20", len(trajectories))

    for idx, (_, row) in enumerate(trajectories.iterrows()):
        color = palette[idx] if isinstance(palette, list) else palette(idx)
        trajectories.loc[[row.name]].plot(
            ax=ax,
            color=color,
            linewidth=2.0,
            alpha=trajectory_alpha,
            label=f"ID {row['id']}",
        )
        if show_pl:
            plot_protection_levels(ax, row, pl_scale, color)

    ax.set_aspect("equal")
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ids_display = ", ".join(str(x) for x in trajectories["id"].tolist())
    ax.set_title(f"CMM Trajectories ({ids_display})")
    ax.legend(loc="best", fontsize="small")
    ax.grid(True, linestyle=":", linewidth=0.3, alpha=0.4)

    output.parent.mkdir(parents=True, exist_ok=True)
    plt.tight_layout()
    fig.savefig(output, dpi=dpi)
    plt.close(fig)


def main(argv: Sequence[str] | None = None) -> None:
    args = parse_args(argv)
    trajectories = load_cmm_trajectories(args.cmm_csv, args.ids)
    if len(trajectories.index) == 0:
        raise SystemExit("No trajectories available to plot.")

    network = load_network(args.network)
    plot_trajectories(
        trajectories,
        network,
        args.output,
        args.dpi,
        tuple(args.figsize),
        args.trajectory_alpha,
        args.road_alpha,
        args.show_pl,
        args.pl_scale,
    )
    print(f"Saved CMM trajectory visualisation -> {args.output}")


if __name__ == "__main__":
    main()
