#!/usr/bin/env python3
"""
Compare ground truth trajectories with CMM trajectory outputs on a single map.

Example:
    python python/plot_compare_trajectories.py \\
        --ground-truth tmp/cmm_test6/ground_truth.csv \\
        --cmm-csv tmp/cmm_test6/cmm_trajectory.csv \\
        --network input/map/haikou/edges.shp \\
        --ids 1 2 \\
        --output tmp/cmm_test6/compare.png
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, Sequence, Set

import json
import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
import shapely.wkt


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot ground truth and CMM trajectories together.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--ground-truth", type=Path, required=True,
                        help="Ground truth CSV generated by generate_data_cmm.py (contains geom column).")
    parser.add_argument("--cmm-csv", type=Path, required=True,
                        help="cmm_trajectory.csv generated by generate_data_cmm.py or CMM outputs.")
    parser.add_argument("--output", type=Path, required=True,
                        help="Destination PNG file.")
    parser.add_argument("--network", type=Path, default=None,
                        help="Optional road network shapefile for background context.")
    parser.add_argument("--ids", type=int, nargs="*", default=None,
                        help="Trajectory IDs to plot. If omitted, plots intersection of IDs in both files.")
    parser.add_argument("--figsize", type=float, nargs=2, default=(10.0, 10.0),
                        metavar=("WIDTH", "HEIGHT"),
                        help="Figure size in inches (width height).")
    parser.add_argument("--dpi", type=int, default=200, help="Rendered image resolution.")
    parser.add_argument("--gt-style", type=str, default="solid",
                        help="Matplotlib line style for ground truth trajectories.")
    parser.add_argument("--cmm-marker", type=str, default="o",
                        help="Matplotlib marker for CMM trajectory points.")
    parser.add_argument("--alpha-gt", type=float, default=0.9,
                        help="Alpha for ground truth lines.")
    parser.add_argument("--alpha-cmm", type=float, default=0.9,
                        help="Alpha for CMM lines.")
    parser.add_argument("--road-alpha", type=float, default=0.6,
                        help="Alpha for background road network.")
    parser.add_argument("--show-pl", action="store_true",
                        help="Draw protection level circles around CMM observations.")
    parser.add_argument("--pl-scale", type=float, default=1.0,
                        help="Multiplier to convert PL values to degrees for plotting.")
    parser.add_argument("--pl-alpha", type=float, default=0.3,
                        help="Alpha for protection level circles.")
    parser.add_argument("--pl-linewidth", type=float, default=0.6,
                        help="Line width for protection level circles.")
    return parser.parse_args(argv)


def load_ground_truth(path: Path) -> gpd.GeoDataFrame:
    df = pd.read_csv(path, delimiter=";")
    if "geom" not in df.columns:
        raise ValueError(f"{path} must contain a 'geom' column with WKT geometries.")
    df["geometry"] = df["geom"].map(shapely.wkt.loads)
    return gpd.GeoDataFrame(df, geometry="geometry", crs="EPSG:4326")


def load_cmm(path: Path) -> gpd.GeoDataFrame:
    df = pd.read_csv(path, delimiter=";")
    if "geom" not in df.columns:
        raise ValueError(f"{path} must contain a 'geom' column with WKT geometries.")
    df["geometry"] = df["geom"].map(shapely.wkt.loads)
    return gpd.GeoDataFrame(df, geometry="geometry", crs="EPSG:4326")


def load_network(path: Path | None) -> gpd.GeoDataFrame | None:
    if path is None:
        return None
    gdf = gpd.read_file(path)
    if gdf.crs is None:
        raise ValueError(f"Network file {path} does not define a CRS.")
    return gdf.to_crs("EPSG:4326")


def select_ids(gt_ids: Set[int], cmm_ids: Set[int], requested: Iterable[int] | None) -> Set[int]:
    if requested:
        requested_set = set(requested)
        missing_gt = requested_set - gt_ids
        missing_cmm = requested_set - cmm_ids
        if missing_gt:
            raise ValueError(f"IDs {sorted(missing_gt)} not found in ground truth data.")
        if missing_cmm:
            raise ValueError(f"IDs {sorted(missing_cmm)} not found in CMM trajectory data.")
        return requested_set
    intersection = gt_ids & cmm_ids
    if not intersection:
        raise ValueError("No overlapping IDs between ground truth and CMM trajectory files.")
    return intersection


def plot_trajectories(gt: gpd.GeoDataFrame,
                      cmm: gpd.GeoDataFrame,
                      selected_ids: Sequence[int],
                      network: gpd.GeoDataFrame | None,
                      output: Path,
                      figsize: tuple[float, float],
                      dpi: int,
                      gt_style: str,
                      cmm_marker: str,
                      alpha_gt: float,
                      alpha_cmm: float,
                      road_alpha: float,
                      show_pl: bool,
                      pl_scale: float,
                      pl_alpha: float,
                      pl_linewidth: float) -> None:
    fig, ax = plt.subplots(figsize=figsize)

    if network is not None:
        network.plot(ax=ax, color="#b0b0b0", linewidth=0.5, alpha=road_alpha, zorder=0)

    try:
        import seaborn as sns  # type: ignore

        palette = sns.color_palette("husl", len(selected_ids))
    except ImportError:
        palette = plt.cm.get_cmap("tab20", len(selected_ids))

    for idx, traj_id in enumerate(selected_ids):
        color = palette[idx] if isinstance(palette, list) else palette(idx)
        gt_row = gt[gt["id"] == traj_id]
        cmm_row = cmm[cmm["id"] == traj_id]
        if gt_row.empty or cmm_row.empty:
            continue
        gt_row.plot(ax=ax, color=color, linestyle=gt_style, linewidth=2.0, alpha=alpha_gt,
                    label=f"GT {traj_id}", zorder=2)
        geometry = cmm_row.geometry.iloc[0]
        prot_levels = json.loads(cmm_row["protection_levels"].iloc[0])
        if geometry.geom_type == "MultiLineString":
            coords = [tuple(pt) for line in geometry.geoms for pt in line.coords]
        else:
            coords = list(geometry.coords)
        xs, ys = zip(*coords)
        ax.scatter(xs, ys, color=color, marker=cmm_marker, alpha=alpha_cmm,
                   label=f"CMM {traj_id}", zorder=3)
        if show_pl:
            for (x, y), pl in zip(coords, prot_levels):
                radius = pl * pl_scale
                circle = plt.Circle(
                    (x, y),
                    radius,
                    edgecolor=color,
                    facecolor="none",
                    alpha=pl_alpha,
                    linewidth=pl_linewidth,
                    zorder=2.5,
                )
                ax.add_patch(circle)

    ax.set_aspect("equal")
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.set_title("Ground Truth vs CMM Trajectories")
    ax.legend(loc="best", fontsize="small")
    ax.grid(True, linestyle=":", linewidth=0.3, alpha=0.4)

    output.parent.mkdir(parents=True, exist_ok=True)
    plt.tight_layout()
    fig.savefig(output, dpi=dpi)
    plt.close(fig)


def main(argv: Sequence[str] | None = None) -> None:
    args = parse_args(argv)
    gt = load_ground_truth(args.ground_truth)
    cmm = load_cmm(args.cmm_csv)
    selected = sorted(select_ids(set(gt["id"].unique()), set(cmm["id"].unique()), args.ids))
    network = load_network(args.network)
    plot_trajectories(
        gt=gt,
        cmm=cmm,
        selected_ids=selected,
        network=network,
        output=args.output,
        figsize=tuple(args.figsize),
        dpi=args.dpi,
        gt_style=args.gt_style,
        cmm_marker=args.cmm_marker,
        alpha_gt=args.alpha_gt,
        alpha_cmm=args.alpha_cmm,
        road_alpha=args.road_alpha,
        show_pl=args.show_pl,
        pl_scale=args.pl_scale,
        pl_alpha=args.pl_alpha,
        pl_linewidth=args.pl_linewidth,
    )
    print(f"Saved comparison plot -> {args.output}")


if __name__ == "__main__":
    main()
